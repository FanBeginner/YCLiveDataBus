# LiveData源码分析
#### 目录介绍
- 01.LiveData的原理介绍
- 02.然后思考一些问题
- 03.observe订阅源码分析
- 04.setValue发送源码分析
- 05.LiveData源码总结
- 06.LiveData流程图绘制





### 01.LiveData的原理介绍
#### 1.1 先看下简单应用
- LiveData是一个数据的包装。具体的包装对象可以是任何数据，包括集合。它是一个抽象类，首先先创建一个类实现LiveData。代码如下所示：
    ```
    public class TextViewModel extends ViewModel {
    
        /**
         * LiveData是抽象类，MutableLiveData是具体实现类
         */
        private MutableLiveData<String> mCurrentText;
    
        public MutableLiveData<String> getCurrentText() {
            if (mCurrentText == null) {
                mCurrentText = new MutableLiveData<>();
            }
            return mCurrentText;
        }
    
    }
    ```
- 创建一个观察的对象，观察LiveData中的数据。目前在组件的onCreate()方法中开始观察数据，代码如下所示：
    - 思考下，可以在onResume()中调用么，个人觉得不太好。因为系统会多次调用onResume()方法。
    ```
    private void initLiveData() {
        // 创建一个持有某种数据类型的LiveData (通常是在ViewModel中)
        model = ViewModelProviders.of(this).get(TextViewModel.class);
        // 创建一个定义了onChange()方法的观察者
        // 开始订阅
        final Observer<String> nameObserver = new Observer<String>() {
            @Override
            public void onChanged(@Nullable final String newText) {
                // 更新数据
                tvText.setText(newText);
            }
        };
        // 通过 observe()方法连接观察者和LiveData，注意：observe()方法需要携带一个LifecycleOwner类
        model.getCurrentText().observe(this, nameObserver);
        
        /*new Thread(new Runnable() {
            @Override
            public void run() {
                model.getCurrentText().observe(ThirdActivity1.this, nameObserver);
            }
        }).start();*/
    }
    ```
- 然后去创建更新对象数据内容的对象。如何去更新那个文本中的数据呢？代码如下所示：
    - 想要在UI Controller中改变LiveData中的值呢？（比如点击某个Button设置文本内容的更改）。
    - LiveData并没有提供这样的功能，但是Architecture Component提供了MutableLiveData这样一个类，可以通过setValue(T)和postValue(T)方法来修改存储在LiveData中的数据。MutableLiveData是LiveData的一个子类，从名称上也能看出这个类的作用。
    - 调用setValue()方法就可以把LiveData中的值改为 "小杨真的是一个逗比么" 。同样，通过这种方法修改LiveData中的值同样会触发所有对这个数据感兴趣的类。那么setValue()和postValue()有什么不同呢？区别就是setValue()只能在主线程中调用，而postValue()可以在子线程中调用。
    ```
    model.getCurrentText().setValue("小杨真的是一个逗比么");
    ```


#### 1.2 简单的原理介绍
- LiveData可对数据进行观测, 并具有生命周期感知能力, 这就意味着当liveData只会在生命周期处于活跃(inActive)的状态下才会去执行观测动作, 而他的能力赋予不能脱离LifeCycle的范围。
- 需要注意的是，LiveData内维护的mVersion表示的是发送信息的版本,每次发送一次信息, 它都会+1, 而ObserverWrapper内维护的mLastVersion为订阅触发的版本号, 当订阅动作生效的时候, 它的版本号会和发送信息的版本号同步.他们初始值都为-1。



### 02.然后思考一些问题
- a.liveData如何实现订阅者模式，如何处理发送事件？
- b.如何做到感知生命周期的，怎么跟 LifecycleOwner 进行绑定的？
- c.LiveData 只在 LifecycleOwner active 状态发送通知，是怎么处理的？
- d.LiveData 会自动在 DESTROY 的状态下取消订阅，是怎么处理的？
- e.生命周期变化后数据处理流程是怎么样的？
- f.为什么观察者只能与一个LifecycleOwner绑定，而不是多个？
- g.
- h.



### 03.observe订阅源码分析
- 直接查看源代码，如下所示：
    - 如果需要与生命周期绑定, 则需要传入LifecycleOwner对象, 将我们的LiveData数据观测者(Observer)包装注册到生命周期的观测者中, 就是源码中创建wrapper对象过程。
    - 需要注意的问题是，不能添加具有不同生命周期的相同观察者，否则就会抛出IllegalArgumentException异常
    - 最后添加一个LifecycleObserver，它将在LifecycleOwner更改状态时得到通知，并做出及时的对应更新活动。
    ```
    @MainThread
    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {
        //当前绑定的组件(activity或者fragment)状态为DESTROYED的时候, 则会忽视当前的订阅请求
        if (owner.getLifecycle().getCurrentState() == DESTROYED) {
            // ignore
            return;
        }
        //创建生命周期感知的观察者包装类
        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
        //如果指定的键尚未与某个值关联，则将其与给定的值关联
        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
        //对应观察者只能与一个owner绑定
        if (existing != null && !existing.isAttachedTo(owner)) {
            throw new IllegalArgumentException("Cannot add the same observer"
                    + " with different lifecycles");
        }
        if (existing != null) {
            return;
        }
        //lifecycle注册
        //添加一个LifecycleObserver，它将在LifecycleOwner更改状态时得到通知
        owner.getLifecycle().addObserver(wrapper);
    }
    ```
- 然后看一下观察者类LifecycleBoundObserver的源代码
    - LifecycleBoundObserver对象, 它继承于ObserverWrapper, 并最终实现了GenericLifecycleObserver接口。
    - 在发生状态转换事件时，会调用onStateChanged方法，在这个方法中，如果是DESTROYED状态，则先要移除观察者，然后在取到生命周期状态变更事件
    ```
    class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {
        @NonNull final LifecycleOwner mOwner;
    
        LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<T> observer) {
            super(observer);
            mOwner = owner;
        }
    
        @Override
        boolean shouldBeActive() {
            return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);
        }
    
        @Override
        public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {
            if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {
                removeObserver(mObserver);
                return;
            }
            activeStateChanged(shouldBeActive());
        }
    
        @Override
        boolean isAttachedTo(LifecycleOwner owner) {
            return mOwner == owner;
        }
    
        @Override
        void detachObserver() {
            mOwner.getLifecycle().removeObserver(this);
        }
    }
    
    //接口
    public interface GenericLifecycleObserver extends LifecycleObserver {
        /**
         * Called when a state transition event happens.
         *
         * @param source The source of the event
         * @param event The event
         */
        void onStateChanged(LifecycleOwner source, Lifecycle.Event event);
    }
    ```


### 04.setValue发送源码分析
- LiveData 更新数据方式有两个，一个是 setValue() 另一个是 postValue()，这两个方法的区别是，postValue() 在内部会抛到主线程去执行更新数据，因此适合在子线程中使用；而 setValue() 则是直接更新数据。
    ```
    @MainThread
    protected void setValue(T value) {
        assertMainThread("setValue");
        // 这里的 mVersion，它本问题关键，每次更新数据都会自增，默认值是 -1。
        mVersion++;
        mData = value;
        dispatchingValue(null);
    }
    ```
- 跟进下 dispatchingValue() 方法，注意，这里需要重点看considerNotify代码：
    ```
    private void dispatchingValue(@Nullable ObserverWrapper initiator) {
        // mDispatchingValue的判断主要是为了解决并发调用dispatchingValue的情况
        // 当对应数据的观察者在执行的过程中, 如有新的数据变更, 则不会再次通知到观察者。所以观察者内的执行不应进行耗时工作
        if (mDispatchingValue) {
            mDispatchInvalidated = true;
            return;
        }
        mDispatchingValue = true;
        do {
            mDispatchInvalidated = false;
            if (initiator != null) {
                // 等下重点看这里的代码
                considerNotify(initiator);
                initiator = null;
            } else {
                for (Iterator<Map.Entry<Observer<T>, ObserverWrapper>> iterator =
                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {
                    // 等下重点看这里的代码
                    considerNotify(iterator.next().getValue());
                    if (mDispatchInvalidated) {
                        break;
                    }
                }
            }
        } while (mDispatchInvalidated);
        mDispatchingValue = false;
    }
    ```
- 然后看一下considerNotify() 方法做了什么，代码如下所示，这里有道词典翻译下注释：
    - 如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。
    - 每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。
    ```
    private void considerNotify(ObserverWrapper observer) {
        if (!observer.mActive) {
            return;
        }
        // 检查最新的状态b4调度。也许它改变了状态，但我们还没有得到事件。
        // 我们还是先检查观察者。活动，以保持它作为活动的入口。
        // 因此,即使观察者移动到一个活动状态，如果我们没有收到那个事件，我们最好不要通知一个更可预测的通知顺序。
        if (!observer.shouldBeActive()) {
            observer.activeStateChanged(false);
            return;
        }
        
        //注意认真看下面的代码
        if (observer.mLastVersion >= mVersion) {
            return;
        }
        observer.mLastVersion = mVersion;
        //noinspection unchecked
        observer.mObserver.onChanged((T) mData);
    }
    ```
- 思考一下dispatchingValue除了setValue会调用，其他还有地方调用么？
    - dispatchingValue除了在我们主动更新数据的时候会触发, 
    - 当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数。
    - 在我们的观察者状态变更(inactive->active)的时候, 也会通知到, 这就导致了LiveData必然支持粘性事件。
    - 如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue。
    ```
    private abstract class ObserverWrapper {
        final Observer<T> mObserver;
        boolean mActive;
        int mLastVersion = START_VERSION;
        //省略部分代码
        void activeStateChanged(boolean newActive) {
            if (newActive == mActive) {
                return;
            }
            // 当observer的状态从active->inactive, 或者inactive->active的时候走以下流程
            // owner
            mActive = newActive;
            boolean wasInactive = LiveData.this.mActiveCount == 0;
            LiveData.this.mActiveCount += mActive ? 1 : -1;
            if (wasInactive && mActive) {
                onActive();
            }
            if (LiveData.this.mActiveCount == 0 && !mActive) {
                onInactive();
            }
            //当observer是从inactive->active的时候，需要通知到观察者
            if (mActive) {
                dispatchingValue(this);
            }
        }
    }
    ```


### 05.LiveData源码总结
- LiveData的观察者可以联动生命周期, 也可以不联动
- LiveData的观察者只能与一个LifecycleOwner绑定, 否则会抛出异常
- 当观察者的active状态变更的时候
- active->inactive : 如果LiveCycler通知OnDestroy, 则移除对应的观察者, 切当所有观察者都非活跃的状态下时, 会触发onInactive
- inactive->active: 会通知观察者最近的数据更新(粘性消息)
- 除了观察者状态变更时, 会接收到数据更新的通知外, 还有一种就是在活跃的情况下, 通过开发者主动更新数据, 会接收到数据更新的通知




















