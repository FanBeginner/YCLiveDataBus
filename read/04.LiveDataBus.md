# liveData实现事件总线
#### 目录介绍
- 01.为何使用liveData
- 02.LiveDataBus的组成
- 03.LiveDataBus原理图
- 04.简单的实现案例代码
- 05.遇到的问题和分析思路



### 01.为何使用liveData


### 02.LiveDataBus的组成
- 消息： 消息可以是任何的 Object，可以定义不同类型的消息，如 Boolean、String。也可以定义自定义类型的消息。
- 消息通道： LiveData 扮演了消息通道的角色，不同的消息通道用不同的名字区分，名字是 String 类型的，可以通过名字获取到一个 LiveData 消息通道。
- 消息总线： 消息总线通过单例实现，不同的消息通道存放在一个 HashMap 中。
- 订阅： 订阅者通过 getChannel() 获取消息通道，然后调用 observe() 订阅这个通道的消息。
- 发布： 发布者通过 getChannel() 获取消息通道，然后调用 setValue() 或者 postValue() 发布消息。



### 03.LiveDataBus原理图
- 为了方便理解，LiveDataBus原理图如下所示
    - ![image](liveDataBus1)



### 04.简单的实现案例代码
- 我这里先用最简单的代码实现liveDataBus，然后用一下，看一下会出现什么问题，代码如下所示：
    ```
    public final class LiveDataBus1 {
    
        private final Map<String, MutableLiveData<Object>> bus;
    
        private LiveDataBus1() {
            bus = new HashMap<>();
        }
    
        private static class SingletonHolder {
            private static final LiveDataBus1 DATA_BUS = new LiveDataBus1();
        }
    
        public static LiveDataBus1 get() {
            return SingletonHolder.DATA_BUS;
        }
    
        public <T> MutableLiveData<T> getChannel(String target, Class<T> type) {
            if (!bus.containsKey(target)) {
                bus.put(target, new MutableLiveData<>());
            }
            return (MutableLiveData<T>) bus.get(target);
        }
    
        public MutableLiveData<Object> getChannel(String target) {
            return getChannel(target, Object.class);
        }
    }
    ```
- 那么如何发送消息和接收消息呢，注意两者的key需要保持一致，否则无法接收？具体代码如下所示：
    ```
    //发送消息
    LiveDataBus1.get().getChannel("yc_bus").setValue(text);
    //接收消息
    LiveDataBus1.get().getChannel("yc_bus", String.class)
            .observe(this, new Observer<String>() {
                @Override
                public void onChanged(@Nullable String newText) {
                    // 更新数据
                    tvText.setText(newText);
                }
            });
    ```


### 05.遇到的问题和分析思路
- 遇到的问题：
    - 1.LiveData 一时使用一时爽，爽完了之后我们发现这个简易的 LiveDataBus 存在一个问题，就是订阅者会收到订阅之前发布的消息，类似于粘性消息。对于一个消息总线来说，这是不可接受的。
    - 2.多次调用了 postValue() 方法，只有最后次调用的值会得到更新。也就是此方法是有可能会丢失事件！
- 然后看一下LiveData的订阅方法observe源码
    - 看下面代码可知道，LiveData 内部会将传入参数包装成 wrapper ，然后存在一个 Map 中，最后通过 LifeCycle 组件添加观察者。
    ```
    // 注释只能在主线程中调用该方法
    @MainThread
    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {
        // 当前绑定的组件(activity or fragment)状态为DESTROYED的时候, 则会忽视当前的订阅请求
        if (owner.getLifecycle().getCurrentState() == DESTROYED) {
            // ignore
            return;
        }
        // 转为带生命周期感知的观察者包装类
        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
        // 对应观察者只能与一个owner绑定，否则抛出异常
        if (existing != null && !existing.isAttachedTo(owner)) {
            throw new IllegalArgumentException("Cannot add the same observer"
                    + " with different lifecycles");
        }
        if (existing != null) {
            return;
        }
        // lifecycle注册
        owner.getLifecycle().addObserver(wrapper);
    }
    ```
- 紧接着，来看一下LiveData的更新数据方法





### 参考内容
- https://juejin.im/post/5dce5b16f265da0ba5279b11








